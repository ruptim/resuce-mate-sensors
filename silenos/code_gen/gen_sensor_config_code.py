#!/usr/bin/env python3

import os
import pathlib
from enum import Enum
import json
from argparse import ArgumentParser
from csnake import CodeWriter, Variable, Function, Subscript, TextModifier
import numpy as np

parser = ArgumentParser()

parser.add_argument(
    "-c",
    "--config",
    type=str,
    required=True,
    help="Config file to generate header for.",
)
parser.add_argument(
    "-o",
    "--out-dir",
    type=str,
    required=False,
    default=pathlib.Path(__file__).parent.parent.joinpath("src").as_posix(),
    help="Output directory of the header file. (Default: ../src)",
)
parser.add_argument(
    "-f", "--format-file", action="store_true", help="Run formatter on generated file."
)


class SensorTypeID(Enum):
    DWAX = "SENSOR_TYPE_ID_DWAX509M183X0"
    REED_NC = "SENSOR_TYPE_ID_REED_SWITCH_NC"
    REED_NO = "SENSOR_TYPE_ID_REED_SWITCH_NO"


class MultiSensorModeID(Enum):
    EQUAL_PARALLEL = 0b00  # equal priority, order doesn't matter
    EQUAL_ORDERED = 0b01  # equal priority, order matters
    WEIGHTED_PARALLEL = 0b10  # different weights/priorities, order doesn't matter
    WEIGHTED_ORDERED = 0b11  # different weights/priorities, order matters


def format_comment_block(lines):
    out = ["/**"]

    for line in lines:
        out.append("* " + line)

    out.append("*/")
    return out


def main():
    args = parser.parse_args()

    data = None
    with open(args.config, "r") as f:
        data = json.load(f)

    cw = CodeWriter()
    cw.add_license_comment(
        "DISCLAIMER: THIS FILE IS GENERATED BY THE code_gen/gen_data_header.py SCRIPT.\nANY CHANGES MADE TO THIS FILE WILL BE OVRITTEN!"
    )
    cw.add_line(ignore_indent=True)

    # cw.start_comment()
    cw.add_lines(
        format_comment_block(
            [
                "@ingroup     silenos",
                "@{",
                "\n",
                "@file",
                "@brief generated sensor config header.",
                "\n",
                "@author      Timon Rupelt <me@ruptim.dev>",
                "@}",
            ]
        )
    )
    # cw.end_comment()
    cw.add_line(ignore_indent=True)

    # cw.add_lines(["#ifndef SENSOR_CONFIG_H_", "#define SENSOR_CONFIG_H_", "\n"])
    cw.add_lines(["#pragma once", "\n"])
    cw.include("sensors.h")
    cw.add_line(ignore_indent=True)

    cw.add_lines(
        [
            "#ifdef __cplusplus",
            "extern C {",
            "#endif",
        ]
    )
    cw.add_line(ignore_indent=True)

    ## ---------------------- start of config code ----------------------------

    # cw.add_line(comment='-' * 30 + 'Sensor Declaration' + '-' * 30)


    # Location string 
    cw.add_line(comment="Location of the sensors defined in the config file.")
    cw.add_define("SENSOR_CONFIG_LOCATION", data.get('location','none'))
    cw.add_line(ignore_indent=True)
    

    # location - polder number
    cw.add_line(comment="Polder number of the location.")
    cw.add_define("SENSOR_CONFIG_LOCATION_POLDER", int( data['location'].split('/')[0].removeprefix('polder')) )
    cw.add_line(ignore_indent=True)

    # location - gate number
    cw.add_line(comment="Gate number of the location.")
    cw.add_define("SENSOR_CONFIG_LOCATION_GATE", int( data['location'].split('/')[1].removeprefix('gate')) )
    cw.add_line(ignore_indent=True)


    num_sensors = len(data["sensors"])
    cw.add_line(comment="Number of physical sensors connected.")
    cw.add_define("NUM_SENSORS", num_sensors)
    cw.add_line(ignore_indent=True)

    num_unique_sensor_values = 0
    for s in data['sensors']:
        num_unique_sensor_values += 1 if s.get('port_pin1') else 0 
        num_unique_sensor_values += 1 if s.get('port_pin2') else 0 

    
    cw.add_line(
        comment="Number of contacts (physical connections) (some sensors have multiple contacts e.g. reed sensors)"
    )
    cw.add_define("NUM_UNIQUE_SENSOR_VALUES", num_unique_sensor_values)
    cw.add_line(ignore_indent=True)

    # get sensor mode
    cw.add_line(comment="Configuration in which the sensors are to be interpreted.")
    cw.add_line(f"#define ACTIVE_MULTI_SENSOR_MODE {MultiSensorModeID['EQUAL_ORDERED'].name}")
    cw.add_line(ignore_indent=True)

    cw.add_line(
        comment="holds all callback arguments for all sensors"
    )
    cw.add_line(
        "extern alarm_cb_args_t alarm_cb_args[NUM_UNIQUE_SENSOR_VALUES];"
    )
    cw.add_line(ignore_indent=True)

    ## create variables for sensor handle and sensor params array
    callback_args = Variable(
        "alarm_cb_args", primitive="alarm_cb_args_t", array="NUM_UNIQUE_SENSOR_VALUES"
    )

    registered_sensors = Variable(
        "registered_sensors", primitive="sensor_base_type_t", array=num_sensors
    )

    registered_sensors_params = Variable(
        "registered_sensors_params", primitive="sensor_base_params_t", array=num_sensors
    )

    cw.add_line(
        comment="IDs for all contacts per sensor to use with parameters and identification in messages."
    )
    cw.add_line(ignore_indent=True)

    # init code defintion
    init_code_lines = []
    init_code_writer = CodeWriter()

    init_code_writer.include("string.h")
    init_code_writer.include("sensor_config.h")
    init_code_writer.add_line(ignore_indent=True)

    ## 'define' arrays in source file
    init_code_writer.add_variable_declaration(callback_args)
    init_code_writer.add_variable_declaration(registered_sensors)
    init_code_writer.add_variable_declaration(registered_sensors_params)
    init_code_writer.add_line(ignore_indent=True)

    init_code_writer.add_line("int init_sensors(void)")
    init_code_writer.open_brace()

    init_code_writer.add_lines("memset(alarm_cb_args, 0, sizeof(alarm_cb_args));\n")
    init_code_writer.add_line(ignore_indent=True)
    if num_sensors > 0:
        init_code_writer.add_lines("int ret = 0;\n")

    id_counter: int = 0
    value_bytes_needed = 0
    for i, s in enumerate(data["sensors"]):
       

        name_base = ""

        if int(s["type"]) == 1:  # REED
            name_base = "reed"

        elif int(s["type"]) == 2:  # INDUCTIVE
            name_base = "dwax"

        else:
            TypeError(f"Type {s['type']} not supported!")

        s_name = f"sensor_{i + 1}_{name_base}"

        sensor_id = TextModifier(f"SENSOR_{i+1}_ID")
        cw.add_define(sensor_id.text, i)

        ## create sensor contact defines and callback arguments

        init_code_writer.add_line(
            f"/* {'-' * 20} init code for sensor '{s_name}' {'-' * 20} */"
        )

        if int(s["type"]) == 1:
            nc_pin =  s.get('port_pin1')
            no_pin = s.get('port_pin2')

            use_internal_pulldown = s.get("internal_pull_down",True)
            def external_pulldown():
                return "true" if not use_internal_pulldown else "false"

            if nc_pin:
                value_bytes_needed += 1 # only 1 byte needed 

                s_id_nc = f"{s_name.upper()}_NC_ID"
                cw.add_define(s_id_nc, id_counter)

                init_code_writer.add_lines(
                    [
                        f"alarm_cb_args[{s_id_nc}].pid = thread_getpid();",
                        f"alarm_cb_args[{s_id_nc}].msg.type = ENCODE_SENSOR_TYPE_IDS({i},{SensorTypeID.REED_NC.value},{s_id_nc});",
                        f"alarm_cb_args[{s_id_nc}].msg.content.ptr = (void *)&{Subscript(registered_sensors, sensor_id)};\n",
                        "\n",
                    ]
                )

                id_counter += 1

            if no_pin:
                ## no

                value_bytes_needed += 1 # only 1 byte needed 

                s_id_no = f"{s_name.upper()}_NO_ID"

                cw.add_define(s_id_no, id_counter)

                init_code_writer.add_lines(
                    [
                        f"alarm_cb_args[{s_id_no}].pid = thread_getpid();",
                        f"alarm_cb_args[{s_id_no}].msg.type = ENCODE_SENSOR_TYPE_IDS({i},{SensorTypeID.REED_NO.value},{s_id_no});",
                        f"alarm_cb_args[{s_id_no}].msg.content.ptr = (void *)&{Subscript(registered_sensors, sensor_id)};",
                        "\n",
                    ]
                )

                id_counter += 1



            if nc_pin and no_pin:
                ## driver init
                init_code_writer.add_lines(
                    [
                        "/* first cast to specific param type and then to base params type for the array. */",
                        f"{Subscript(registered_sensors_params, sensor_id)} = (sensor_base_params_t) (reed_sensor_driver_params_t) {{",
                        f"    .nc_pin = GPIO_PIN({s['port_pin1'][0]},{s['port_pin1'][1]}),",
                        f"    .no_pin = GPIO_PIN({s['port_pin2'][0]},{s['port_pin2'][1]}),",
                        f"    .nc_int_flank = GPIO_BOTH,",
                        f"    .no_int_flank = GPIO_BOTH,",
                        f"    .nc_callback = reed_nc_callback,",
                        f"    .no_callback = reed_no_callback,",
                        f"    .nc_callback_args = (void *)&alarm_cb_args[{s_id_nc}],",
                        f"    .no_callback_args = (void *)&alarm_cb_args[{s_id_no}],",
                        f"    .use_external_pulldown = {external_pulldown()},",
                        f"    .debounce_ms = REED_SENSOR_DEBOUNCE_MS }};",
                        "\n",
                        f"if ((ret = reed_sensor_driver_init(&{Subscript(registered_sensors, sensor_id)}.reed_sensor, &{Subscript(registered_sensors_params, sensor_id)}.reed_sensor_params)) != 0){{",
                        "\treturn ret;",
                        "}",
                        "\n\n",
                    ]
                )
            elif nc_pin:
                 init_code_writer.add_lines(
                    [
                        "/* first cast to specific param type and then to base params type for the array. */",
                        f"{Subscript(registered_sensors_params, sensor_id)} = (sensor_base_params_t) (reed_sensor_driver_params_t) {{",
                        f"    .nc_pin = GPIO_PIN({s['port_pin1'][0]},{s['port_pin1'][1]}),",
                        f"    .nc_int_flank = GPIO_BOTH,",
                        f"    .nc_callback = reed_nc_callback,",
                        f"    .nc_callback_args = (void *)&alarm_cb_args[{s_id_nc}],",
                        f"    .use_external_pulldown = {external_pulldown()},",
                        f"    .debounce_ms = REED_SENSOR_DEBOUNCE_MS }};",
                        "\n",
                        f"if ((ret = reed_sensor_driver_init(&{Subscript(registered_sensors, sensor_id)}.reed_sensor, &{Subscript(registered_sensors_params, sensor_id)}.reed_sensor_params)) != 0){{",
                        "\treturn ret;",
                        "}",
                        "\n\n",
                    ]
                )
            
            else:
                init_code_writer.add_lines(
                [
                    "/* first cast to specific param type and then to base params type for the array. */",
                    f"{Subscript(registered_sensors_params, sensor_id)} = (sensor_base_params_t) (reed_sensor_driver_params_t) {{",
                    f"    .no_pin = GPIO_PIN({s['port_pin2'][0]},{s['port_pin2'][1]}),",
                    f"    .no_int_flank = GPIO_BOTH,",
                    f"    .no_callback = reed_no_callback,",
                    f"    .no_callback_args = (void *)&alarm_cb_args[{s_id_no}],",
                    f"    .use_external_pulldown = {external_pulldown()},",
                    f"    .debounce_ms = REED_SENSOR_DEBOUNCE_MS }};",
                    "\n",
                    f"if ((ret = reed_sensor_driver_init(&{Subscript(registered_sensors, sensor_id)}.reed_sensor, &{Subscript(registered_sensors_params, sensor_id)}[{i}].reed_sensor_params)) != 0){{",
                    "\treturn ret;",
                    "}",
                    "\n\n",
                ]
            )

        elif int(s["type"]) == 2:
            value_bytes_needed += int(np.iinfo(np.uint32).bits/4) # 4 bytes needed 
            s_id = f"{s_name.upper()}_ID"
            cw.add_define(s_id, id_counter)
            init_code_writer.add_lines(
                [
                    f"alarm_cb_args[{s_id}].pid = thread_getpid();"
                    f"alarm_cb_args[{s_id}].msg.type = ENCODE_SENSOR_TYPE_IDS({i},{SensorTypeID.DWAX.value},{s_id});"
                    f"alarm_cb_args[{s_id}].msg.content.ptr = (void *)&{Subscript(registered_sensors, sensor_id)};",
                    "\n",
                ]
            )
            id_counter += 1
            # TODO: initialization of dwax

        cw.add_line(ignore_indent=True)

    ## close init function
    init_code_writer.add_lines(init_code_lines + ["return 0;"])
    init_code_writer.close_brace()

    cw.add_line(comment=" The number of maximum bytes needed for all sensor values.")
    cw.add_define("SENSORS_MAX_VALUE_BYTES_NEEDED", value_bytes_needed)
    cw.add_line(ignore_indent=True)

    ## add extern declaration for  sensor handle and sensor params array
    cw.add_variable_declaration(registered_sensors, extern=True)
    cw.add_variable_declaration(registered_sensors_params, extern=True)
    cw.add_line(ignore_indent=True)

    # init function

    cw.add_line(ignore_indent=True)
    cw.add_lines(
        format_comment_block(
            [
                "@brief  Intiatialize all configured sensors with their corresponding drivers and parameters.",
                "\n",
                "@return 0 if all drivers where intialized correctly, -1 otherwise.",
            ]
        )
    )

    cw.add_line("int init_sensors(void);")
    cw.add_line(ignore_indent=True)
    cw.add_line(ignore_indent=True)

    # ---------------------- header footer ---------------------------

    cw.add_lines(
        [
            "#ifdef __cplusplus",
            "}",
            "#endif",
        ]
    )
    cw.add_line(ignore_indent=True)
    # cw.add_line("#endif // SENSOR_CONFIG_H_")

    # ---------------------- export header -----------------------------

    print(f"[CODE GEN] Writing writing files to dir: {args.out_dir}")
    header_file_path = pathlib.Path(args.out_dir).joinpath("sensor_config.h")
    with open(header_file_path, "w") as f:
        f.writelines(cw.code)

    if args.format_file:
        os.system(f"clang-format -i {header_file_path}")

    # ---------------------- export source -----------------------------

    source_file_path = pathlib.Path(args.out_dir).joinpath("sensor_config.c")
    with open(source_file_path, "w") as f:
        f.writelines(init_code_writer.code)

    if args.format_file:
        os.system(f"clang-format -i {source_file_path}")


if __name__ == "__main__":
    main()
